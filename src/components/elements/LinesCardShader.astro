---
type Props = {
  class?: string
  id?: string
  size?: number
  background?: string // hex, e.g. '#f5f7fa'
  lineColor?: string // hex, e.g. '#9aa6b2'
  accentColor?: string // hex, e.g. '#7f38dc' (muted usage)
  lineOpacity?: number // 0..1
  lineDensity?: number // e.g. 18..40
  speed?: number // e.g. 0.25..1.2
  mouseStrength?: number // 0..1
  dprCap?: number // e.g. 1.0..2.0
}

const {
  class: className = '',
  id: providedId,
  size = 300,
  background = '#f5f7fa',
  lineColor = '#9aa6b2',
  accentColor = '#7f38dc',
  lineOpacity = 0.55,
  lineDensity = 10,
  speed = 0.15,
  mouseStrength = 0.5,
  dprCap = 1.5,
} = Astro.props as Props

const id = providedId ?? `terrain-lines-${Math.random().toString(36).slice(2)}`
---

<div class={`terrain-lines ${className}`}>
  <canvas id={id} class="terrain-lines__canvas" aria-hidden="true"></canvas>
</div>

<style>
  .terrain-lines {
    width: 100%;
    height: 100%;
    overflow: hidden;
    position: relative;
  }

  .terrain-lines__canvas {
    width: 100%;
    height: 100%;
    display: block;
  }

  @media (prefers-reduced-motion: reduce) {
    .terrain-lines {
      display: none;
    }
  }
</style>

<script is:inline define:vars={{
  id,
  size,
  background,
  lineColor,
  accentColor,
  lineOpacity,
  lineDensity,
  speed,
  mouseStrength,
  dprCap
}}>
  ;(() => {
    const canvas = document.getElementById(id)
    if (!canvas) return

    const prefersReduced = window.matchMedia?.('(prefers-reduced-motion: reduce)')?.matches
    if (prefersReduced) {
      canvas.style.display = 'none'
      return
    }

    const hexToRgb01 = (hex) => {
      const cleaned = String(hex).trim().replace('#', '')
      const full = cleaned.length === 3
        ? cleaned.split('').map((c) => c + c).join('')
        : cleaned

      const num = Number.parseInt(full, 16)
      const r = (num >> 16) & 255
      const g = (num >> 8) & 255
      const b = num & 255

      return [r / 255, g / 255, b / 255]
    }

    const bg = hexToRgb01(background)
    const line = hexToRgb01(lineColor)
    const accent = hexToRgb01(accentColor)

    const gl =
      canvas.getContext('webgl', {
        antialias: false,
        alpha: true,
        depth: false,
        stencil: false,
        powerPreference: 'high-performance',
      }) ||
      canvas.getContext('experimental-webgl', {
        antialias: false,
        alpha: true,
        depth: false,
        stencil: false,
        powerPreference: 'high-performance',
      })

    if (!gl) {
      canvas.style.display = 'none'
      return
    }

    const vertSrc = `
      attribute vec2 a_pos;
      varying vec2 v_uv;
      void main() {
        v_uv = (a_pos * 0.5) + 0.5;
        gl_Position = vec4(a_pos, 0.0, 1.0);
      }
    `

    const fragSrc = `
      precision highp float;

      varying vec2 v_uv;
      uniform vec2 u_res;
      uniform float u_time;
      uniform vec2 u_mouse;   // 0..1
      uniform vec3 u_bg;
      uniform vec3 u_line;
      uniform vec3 u_accent;
      uniform float u_opacity;
      uniform float u_density;
      uniform float u_speed;
      uniform float u_mouseStrength;

      float hash12(vec2 p) {
        vec3 p3 = fract(vec3(p.xyx) * 0.1031);
        p3 += dot(p3, p3.yzx + 33.33);
        return fract((p3.x + p3.y) * p3.z);
      }

      float noise2(vec2 p) {
        vec2 i = floor(p);
        vec2 f = fract(p);
        vec2 u = f * f * (3.0 - 2.0 * f);

        float a = hash12(i + vec2(0.0, 0.0));
        float b = hash12(i + vec2(1.0, 0.0));
        float c = hash12(i + vec2(0.0, 1.0));
        float d = hash12(i + vec2(1.0, 1.0));

        return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
      }

      float fbm(vec2 p) {
        float v = 0.0;
        float a = 0.5;
        for (int i = 0; i < 5; i++) {
          v += a * noise2(p);
          p *= 2.02;
          a *= 0.5;
        }
        return v;
      }

      vec2 warp(vec2 p, float t) {
        float w1 = fbm(p * 1.2 + vec2(0.0, 1.7) + t);
        float w2 = fbm(p * 1.2 + vec2(2.3, 0.4) - t * 0.9);
        return vec2(w1, w2);
      }

      void main() {
        vec2 frag = v_uv * u_res;
        vec2 p = (frag - 0.5 * u_res) / u_res.y;

        // mouse influence
        vec2 m = (u_mouse - 0.5) * 2.0;
        p += m * 0.18 * u_mouseStrength;

        float t = u_time * u_speed;

        // domain warp for "terrain"
        vec2 q = p * 2.2;
        vec2 w = warp(q + m * 0.35 * u_mouseStrength, t * 0.25);
        q += (w - 0.5) * 0.85;

        float h = fbm(q + vec2(t * 0.15, -t * 0.12));

        // contour lines
        float dens = max(4.0, u_density);
        float bands = h * dens;

        // distance to nearest contour center
        float c = abs(fract(bands) - 0.5);

        // approximate AA thickness in UV/pixel terms
        float px = 1.0 / max(u_res.x, u_res.y);
        float thickness = mix(0.08, 0.015, 1.0 - u_opacity) + px * 10.5;
        // float thickness = 0.02 + px * 5.0;

        float lineMask = smoothstep(thickness, 0.0, c);

        // subtle secondary micro-lines
        float c2 = abs(fract(h * (dens * 0.5) + 0.17) - 0.5);
        float micro = smoothstep(thickness * 0.9, 0.0, c2) * 0.35;

        // light shading to make it feel "geo"
        float shade = smoothstep(0.15, 0.9, h);
        vec3 base = u_bg;

        // slight vignette for card feel
        float r = length(p);
        base *= 1.0 - 0.06 * smoothstep(0.35, 1.0, r);

        // line color is mostly muted, with a tiny accent tint driven by height
        vec3 lc = mix(u_line, u_accent, 0.18 * smoothstep(0.2, 0.95, h));
        float alpha = clamp((lineMask + micro) * u_opacity, 0.0, 1.0);

        // push lines darker where terrain is "steeper"
        float contrast = mix(0.85, 1.05, shade);
        vec3 col = mix(base, lc * contrast, alpha);

        gl_FragColor = vec4(col, 1.0);
      }
    `

    function compileShader(type, source) {
      const shader = gl.createShader(type)
      gl.shaderSource(shader, source)
      gl.compileShader(shader)

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const msg = gl.getShaderInfoLog(shader) || 'Shader compile failed'
        gl.deleteShader(shader)
        throw new Error(msg)
      }

      return shader
    }

    function createProgram(vsSrc, fsSrc) {
      const vs = compileShader(gl.VERTEX_SHADER, vsSrc)
      const fs = compileShader(gl.FRAGMENT_SHADER, fsSrc)
      const program = gl.createProgram()

      gl.attachShader(program, vs)
      gl.attachShader(program, fs)
      gl.linkProgram(program)

      gl.deleteShader(vs)
      gl.deleteShader(fs)

      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        const msg = gl.getProgramInfoLog(program) || 'Program link failed'
        gl.deleteProgram(program)
        throw new Error(msg)
      }

      return program
    }

    let program
    try {
      program = createProgram(vertSrc, fragSrc)
    } catch (err) {
      console.error('[TerrainLinesCanvas] shader init failed', err)
      canvas.style.display = 'none'
      return
    }

    gl.useProgram(program)

    const posLoc = gl.getAttribLocation(program, 'a_pos')

    const uRes = gl.getUniformLocation(program, 'u_res')
    const uTime = gl.getUniformLocation(program, 'u_time')
    const uMouse = gl.getUniformLocation(program, 'u_mouse')
    const uBg = gl.getUniformLocation(program, 'u_bg')
    const uLine = gl.getUniformLocation(program, 'u_line')
    const uAccent = gl.getUniformLocation(program, 'u_accent')
    const uOpacity = gl.getUniformLocation(program, 'u_opacity')
    const uDensity = gl.getUniformLocation(program, 'u_density')
    const uSpeed = gl.getUniformLocation(program, 'u_speed')
    const uMouseStrength = gl.getUniformLocation(program, 'u_mouseStrength')

    const buf = gl.createBuffer()
    gl.bindBuffer(gl.ARRAY_BUFFER, buf)
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 3, -1, -1, 3]), gl.STATIC_DRAW)

    gl.enableVertexAttribArray(posLoc)
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0)

    // sizing / DPR
    const dprLimit = Math.max(1, Math.min(Number(dprCap) || 1.5, 2))
    let dpr = Math.min(window.devicePixelRatio || 1, dprLimit)

    function resize() {
      const rect = canvas.getBoundingClientRect()
      if (rect.width < 2 || rect.height < 2) return

      const w = Math.floor(rect.width * dpr)
      const h = Math.floor(rect.height * dpr)

      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w
        canvas.height = h
        gl.viewport(0, 0, w, h)
      }
    }

    const ro = new ResizeObserver(() => resize())
    ro.observe(canvas)

    // visibility pause (important if you have several cards)
    let running = true
    const io = new IntersectionObserver(
      (entries) => {
        running = entries.some((e) => e.isIntersecting)
      },
      { threshold: 0.01 }
    )
    io.observe(canvas)

    // mouse
    let mouseX = 0.5
    let mouseY = 0.5
    let smX = 0.5
    let smY = 0.5

    function onPointerMove(e) {
      const rect = canvas.getBoundingClientRect()
      if (rect.width <= 0 || rect.height <= 0) return
      mouseX = (e.clientX - rect.left) / rect.width
      mouseY = 1 - (e.clientY - rect.top) / rect.height
      mouseX = Math.max(0, Math.min(1, mouseX))
      mouseY = Math.max(0, Math.min(1, mouseY))
    }

    canvas.addEventListener('pointermove', onPointerMove, { passive: true })
    canvas.addEventListener('pointerleave', () => {
      mouseX = 0.5
      mouseY = 0.5
    }, { passive: true })

    // static uniforms
    gl.uniform3f(uBg, bg[0], bg[1], bg[2])
    gl.uniform3f(uLine, line[0], line[1], line[2])
    gl.uniform3f(uAccent, accent[0], accent[1], accent[2])
    gl.uniform1f(uOpacity, Math.max(0, Math.min(1, Number(lineOpacity) || 0.55)))
    gl.uniform1f(uDensity, Math.max(2, Number(lineDensity) || 28))
    gl.uniform1f(uSpeed, Math.max(0.05, Number(speed) || 0.55))
    gl.uniform1f(uMouseStrength, Math.max(0, Math.min(1, Number(mouseStrength) || 0.5)))

    // animation
    let start = performance.now()
    let last = start
    let quality = 1.0

    function frame(now) {
      requestAnimationFrame(frame)
      if (!running) return

      const dt = now - last
      last = now

      // tiny adaptive DPR (usually overkill, but safe with multiple instances)
      if (dt > 22) quality = Math.max(0.75, quality - 0.03)
      else if (dt < 17) quality = Math.min(1.0, quality + 0.01)

      const targetDpr = Math.min((window.devicePixelRatio || 1) * quality, dprLimit)
      if (Math.abs(targetDpr - dpr) > 0.02) dpr = targetDpr

      resize()

      // smooth mouse
      smX += (mouseX - smX) * 0.08
      smY += (mouseY - smY) * 0.08

      const t = (now - start) / 1000

      gl.uniform2f(uRes, canvas.width, canvas.height)
      gl.uniform1f(uTime, t)
      gl.uniform2f(uMouse, smX, smY)

      gl.drawArrays(gl.TRIANGLES, 0, 3)
    }

    // optional fixed size (if you want *exact* 300x300)
    // canvas.style.width = `${size}px`
    // canvas.style.height = `${size}px`

    resize()
    requestAnimationFrame(frame)
  })()
</script>
