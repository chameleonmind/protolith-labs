---
import { Image } from 'astro:assets'

type Props = {
  class?: string
  src: any
  alt?: string
  width?: number
  height?: number

  // holographic tuning
  maxTiltDeg?: number
  glareStrength?: number // 0..1
  holoOpacity?: number // 0..1
  colors?: Array<string> // 2-5 hex/rgb strings
}

const {
  class: className = '',
  src,
  alt = '',
  width,
  height,
  maxTiltDeg = 10,
  glareStrength = 0.55,
  holoOpacity = 0.55,
  colors = ['#7f38dc', '#cf0177', '#ff5641', '#4cc9f0'],
} = Astro.props as Props

const id = `holo-tilt-${Math.random().toString(36).slice(2)}`
const gradient = `linear-gradient(120deg, ${colors.join(', ')})`
---

<div
  id={id}
  class={`holo ${className}`}
  style={`
    --holo-gradient: ${gradient};
    --max-tilt: ${maxTiltDeg}deg;
    --glare-strength: ${glareStrength};
    --holo-opacity: ${holoOpacity};
  `}
>
  <Image src={src} alt={alt} {width} {height} />
</div>

<style lang="scss">
  .holo {
    position: relative;
    display: grid;
    place-items: center;

    border-radius: 18px;
    overflow: hidden;

    /* perf: keep updates on compositor */
    transform-style: preserve-3d;
    will-change: transform;

    /* driven by JS */
    --rx: 0deg;
    --ry: 0deg;
    --mx: 50%;
    --my: 50%;
  }

  .holo > img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;

    transform: translateZ(0.01px); /* force compositing */
    will-change: transform;
    backface-visibility: hidden;
  }

  /* Base tilt */
  .holo {
    transform:
      perspective(900px)
      rotateX(var(--rx))
      rotateY(var(--ry));
    transition: transform 120ms ease;
  }

  /* Holographic film */
  .holo::before {
    content: '';
    position: absolute;
    inset: 0;
    pointer-events: none;

    background: var(--holo-gradient);
    mix-blend-mode: screen;
    opacity: var(--holo-opacity);

    /* "move" gradient with mouse */
    background-size: 220% 220%;
    background-position: var(--mx) var(--my);

    filter: saturate(1.2) contrast(1.05);
    transform: translateZ(0.02px);
  }

  /* Glare / light spot */
  .holo::after {
    content: '';
    position: absolute;
    inset: -30%;
    pointer-events: none;

    background: radial-gradient(
      circle at var(--mx) var(--my),
      rgba(255, 255, 255, calc(var(--glare-strength) * 0.85)) 0%,
      rgba(255, 255, 255, calc(var(--glare-strength) * 0.35)) 18%,
      rgba(255, 255, 255, 0) 55%
    );

    mix-blend-mode: overlay;
    opacity: 0.9;
    transform: translateZ(0.03px);
  }

  /* Optional: subtle “foil” grain (cheap) */
  .holo .holo__grain {
    display: none;
  }

  /* Hover polish */
  @media (hover: hover) {
    .holo:hover {
      transition: transform 40ms linear;
    }
  }

  @media (prefers-reduced-motion: reduce) {
    .holo {
      transform: none !important;
      transition: none !important;
    }
    .holo::before,
    .holo::after {
      display: none;
    }
  }
</style>

<script is:inline define:vars={{ id, maxTiltDeg }}>
  ;(() => {
    const el = document.getElementById(id)
    if (!el) return

    const prefersReduced = window.matchMedia?.('(prefers-reduced-motion: reduce)')?.matches
    if (prefersReduced) return

    const clamp = (v, min, max) => Math.max(min, Math.min(max, v))
    const maxTilt = Number(maxTiltDeg) || 10

    let raf = 0
    let targetRx = 0
    let targetRy = 0
    let curRx = 0
    let curRy = 0
    let targetMx = 50
    let targetMy = 50
    let curMx = 50
    let curMy = 50

    function apply() {
      raf = 0

      // smooth (cheap spring-ish lerp)
      curRx += (targetRx - curRx) * 0.12
      curRy += (targetRy - curRy) * 0.12
      curMx += (targetMx - curMx) * 0.15
      curMy += (targetMy - curMy) * 0.15

      el.style.setProperty('--rx', `${curRx.toFixed(3)}deg`)
      el.style.setProperty('--ry', `${curRy.toFixed(3)}deg`)
      el.style.setProperty('--mx', `${curMx.toFixed(2)}%`)
      el.style.setProperty('--my', `${curMy.toFixed(2)}%`)
    }

    function schedule() {
      if (raf) return
      raf = requestAnimationFrame(apply)
    }

    function onMove(e) {
      const rect = el.getBoundingClientRect()
      if (rect.width <= 0 || rect.height <= 0) return

      const x = (e.clientX - rect.left) / rect.width
      const y = (e.clientY - rect.top) / rect.height

      const nx = clamp(x, 0, 1) * 2 - 1
      const ny = clamp(y, 0, 1) * 2 - 1

      // tilt: invert Y so moving up tilts "towards" you
      targetRx = (-ny * maxTilt)
      targetRy = (nx * maxTilt)

      targetMx = clamp(x, 0, 1) * 100
      targetMy = clamp(y, 0, 1) * 100

      schedule()
    }

    function reset() {
      targetRx = 0
      targetRy = 0
      targetMx = 50
      targetMy = 50
      schedule()
    }

    el.addEventListener('pointermove', onMove, { passive: true })
    el.addEventListener('pointerleave', reset, { passive: true })
    el.addEventListener('pointerdown', onMove, { passive: true })
  })()
</script>
